# QuantumESPRESSO Single-Point SCF with SOC

import os
import re
from pathlib import Path
from math import ceil, pi
import numpy as np
import subprocess
from subprocess import CalledProcessError
from ase import Atoms
from ase.io import read
from ase.data import atomic_masses, atomic_numbers
from ase.build import bulk
from mendeleev import element


# ASE structure
bi = bulk('Bi', 'rhombohedral', a=4.75, c=12.36, orthorhombic=False)

def run_qe(
    structure,
    config,
    input_filename='espresso.pwi',
    output_filename='espresso.pwo'
):
    """
    Run a Quantum ESPRESSO calculation for a given ASE structure.

    :param structure: ASE Atoms object defining the system.
    :param config: A dictionary containing the following keys:
                   {
                     'command': path to pw.x or mpirun + pw.x,
                     'pseudo_dir': directory containing pseudopotential files,
                     'outdir': output directory for QE,
                     'control': dict with QE &CONTROL namelist inputs,
                     'system': dict with QE &SYSTEM namelist inputs,
                     'electrons': dict with QE &ELECTRONS namelist inputs
                   }
    :param input_filename: Name of the input file to be generated.
    :param output_filename: Name of the output file generated by QE.
    """

    def pseudopotentials(ase_structure, pseudo_directory):
        """
        Determine the appropriate pseudopotential file for each atomic species
        from the given directory. Tries to pick up 'fr' (fully relativistic) files
        if they are present; otherwise, picks the first found.
        """
        species = set(atom.symbol for atom in ase_structure)
        pseudopot_dict = {}
        pseudo_path = Path(pseudo_directory)
        for symbol in species:
            candidates = []
            for pp_file in pseudo_path.glob('*.[uU][pP][fF]'):
                pp_stem = pp_file.stem.split('_')[0].split('.')[0]
                if pp_stem.lower() == symbol.lower():
                    candidates.append(pp_file)
            if not candidates:
                raise FileNotFoundError(f"No pseudopotential found for {symbol}")
            # Prefer 'fr' if available
            fr_files = [c for c in candidates if 'fr' in c.stem.lower()]
            selected = max(fr_files, key=lambda x: len(x.stem)) if fr_files else candidates[0]
            pseudopot_dict[symbol] = selected.name

        return pseudopot_dict

    def pseudo_cutoffs(pseudopot_dict, pseudo_directory):
        """
        Parse each pseudopotential file for wfc_cutoff and/or rho_cutoff.
        If none of the files has wfc_cutoff, assume the single key we find
        (rho_cutoff) is actually wfc_cutoff, then ecutrho = 4*wfc_cutoff.
        Finally, multiply each by 1.15 and round up.

        Returns (final_ecutwfc, final_ecutrho)
        """
        all_wfc = []
        all_rho = []
        for _, pp_filename in pseudopot_dict.items():
            pp_path = Path(pseudo_directory) / pp_filename
            with open(pp_path, 'r') as f:
                content = f.read()
            # Regex to grab wfc_cutoff, rho_cutoff
            wfc_match = re.search(r'wfc_cutoff\s*=\s*"?\s*(?P<val>[\d.+Ee-]+)\s*"?', content)
            rho_match = re.search(r'rho_cutoff\s*=\s*"?\s*(?P<val>[\d.+Ee-]+)\s*"?', content)
            # Parse wfc_cutoff if found
            if wfc_match:
                raw_wfc = wfc_match.group('val').strip()
                # Normalize exponentials
                raw_wfc = raw_wfc.replace('E+', 'E').replace('e+', 'e')
                wfc_val = float(raw_wfc)
                all_wfc.append(wfc_val)
            # Parse rho_cutoff if found
            if rho_match:
                raw_rho = rho_match.group('val').strip()
                # Normalize exponentials
                raw_rho = raw_rho.replace('E+', 'E').replace('e+', 'e')
                rho_val = float(raw_rho)
                all_rho.append(rho_val)
        # Decide final cutoffs based on presence of wfc_cutoff
        if len(all_wfc) == 0:
            # That means each file must have had only 'rho_cutoff', which is wfc.
            # We'll use the maximum of those as ecutwfc, and ecutrho = 4 * ecutwfc.
            if not all_rho:
                # No cutoffs found at all
                raise ValueError("No wfc_cutoff or rho_cutoff found in any pseudopotential file.")
            max_wfc = max(all_rho)
            max_rho = 4.0 * max_wfc
        else:
            # We have proper wfc_cutoff in each file (and presumably also rho_cutoff).
            max_wfc = max(all_wfc)
            max_rho = max(all_rho)
        # Multiply by 1.15 to be safe, then round up
        ecutwfc = ceil(max_wfc * 1.15)
        ecutrho = ceil(max_rho * 1.15)

        return ecutwfc, ecutrho

    def kpoints(atoms, k_spacing=0.13, shift=(1,1,1)):
        """
        Given an ASE Atoms object and a desired k-point spacing k_spacing (in Å^-1),
        compute a suitable (n1, n2, n3) Monkhorst–Pack grid.

        Parameters
        atoms : ase.Atoms
            An ASE Atoms object with a defined cell.
        k_spacing : float
            Target spacing in reciprocal space, in Å^-1. Default is 0.02 Å^-1.
        shift : tuple of int
            The Monkhorst-Pack shift for each direction, either (0,0,0) or (1,1,1).

        Returns
        (n1, n2, n3, s1, s2, s3) : tuple of ints
            The grid subdivisions (n1, n2, n3) and the shift (s1, s2, s3).
        """
        # Extract real-space lattice vectors
        cell = atoms.get_cell()  # 3x3 array
        a1, a2, a3 = [np.array(vec) for vec in cell]

        # Compute real-space volume
        volume = np.dot(a1, np.cross(a2, a3))

        # Compute reciprocal lattice vectors b1, b2, b3
        # b1 = 2π * (a2 × a3) / (a1 · (a2 × a3)), etc.
        b1 = 2 * pi * np.cross(a2, a3) / volume
        b2 = 2 * pi * np.cross(a3, a1) / volume
        b3 = 2 * pi * np.cross(a1, a2) / volume

        # Compute magnitudes of reciprocal vectors
        b1_len = np.linalg.norm(b1)
        b2_len = np.linalg.norm(b2)
        b3_len = np.linalg.norm(b3)

        # Determine the number of divisions along each direction
        n1 = max(1, ceil(b1_len / k_spacing))
        n2 = max(1, ceil(b2_len / k_spacing))
        n3 = max(1, ceil(b3_len / k_spacing))

        # Unpack the shift
        s1, s2, s3 = shift

        return (n1, n2, n3, s1, s2, s3)

    def nbnd(atoms):
        # Sum valence electrons for each atom
        total_valence = 0
        for atom in atoms:
            symbol = atom.symbol
            elem = element(symbol)
            valence = elem.nvalence()
            total_valence += valence
        # Calculate recommended nbnd with safety factor
        # Typically we use max(int(total_valence * 0.7), int(total_valence * 0.5) + 4) for a metal
        nbnd = max(int(total_valence * 1.2), int(total_valence * 0.7) + 4)

        return nbnd

    def write_espresso_input(
        ase_structure,
        qe_config,
        pps,
        kpoints,
        filename
    ):
        """
        Write the Quantum ESPRESSO input file from an ASE structure, config,
        and selected pseudopotentials.
        """
        with open(filename, 'w') as f:
            # Control section
            f.write('&control\n')
            for key, value in qe_config['control'].items():
                if isinstance(value, bool):
                    val = '.true.' if value else '.false.'
                elif isinstance(value, str):
                    val = f"'{value}'"
                else:
                    val = value
                f.write(f"  {key} = {val}\n")
            f.write('/\n')

            # System section
            f.write('&system\n')
            for key, value in qe_config['system'].items():
                if isinstance(value, bool):
                    val = '.true.' if value else '.false.'
                elif isinstance(value, str):
                    val = f"'{value}'"
                else:
                    val = value
                f.write(f"  {key} = {val}\n")
            f.write('/\n')

            # Electrons section
            f.write('&electrons\n')
            for key, value in qe_config['electrons'].items():
                if isinstance(value, bool):
                    val = '.true.' if value else '.false.'
                elif isinstance(value, str):
                    val = f"'{value}'"
                else:
                    val = value
                f.write(f"  {key} = {val}\n")
            f.write('/\n')

            # Atomic species
            f.write('\nATOMIC_SPECIES\n')
            unique_symbols = set(ase_structure.get_chemical_symbols())
            for symbol in unique_symbols:
                mass = atomic_masses[atomic_numbers[symbol]]
                f.write(f"  {symbol.title()} {mass:.4f} {pps[symbol]}\n")

            # Atomic positions
            f.write('\nATOMIC_POSITIONS angstrom\n')
            abs_pos = ase_structure.get_positions()
            for atom, pos in zip(ase_structure, abs_pos):
                f.write(f"  {atom.symbol.title()} "
                        f"{pos[0]:.10f} {pos[1]:.10f} {pos[2]:.10f}\n")

            # K-points grid
            f.write('\nK_POINTS automatic\n')
            f.write(f"  {kpoints[0]} {kpoints[1]} {kpoints[2]} {kpoints[3]} {kpoints[4]} {kpoints[5]}\n")

            # Cell parameters in angstrom
            f.write('\nCELL_PARAMETERS angstrom\n')
            for vec in ase_structure.cell:
                f.write(f"  {vec[0]:.10f} {vec[1]:.10f} {vec[2]:.10f}\n")

    # Unpack top-level config items
    command = config['command']
    pseudo_dir = config['pseudo_dir']
    outdir = config['outdir']
    os.makedirs(outdir, exist_ok=True)
    # Set nat and ntyp based on the current structure
    config['system']['nat'] = len(structure)
    config['system']['ntyp'] = len(set(structure.get_chemical_symbols()))
    # Set Pseudos
    pseudopotentials = pseudopotentials(structure, pseudo_dir)
    # Set Cutoffs
    ecutwfc, ecutrho = pseudo_cutoffs(pseudopotentials, pseudo_dir)
    config['system']['ecutwfc'] = ecutwfc
    config['system']['ecutrho'] = ecutrho
    # Set k-points
    kpts = kpoints(atoms, k_spacing=0.13, shift=(1,1,1))
    # Set bands
    config['system']['nbnd'] = nbnd(structure)
    # write inout file
    write_espresso_input(structure, config, pseudopotentials, kpts, input_filename)
    # Subprocess run
    try:
        with open(output_filename, 'w') as f_out:
            subprocess.run(
                [command, '-in', input_filename],
                stdout=f_out,
                stderr=subprocess.STDOUT,
                check=True
            )
        print("QE calculation completed successfully.")

    except CalledProcessError as cpe:
        print(f"Error running QE: {cpe}")
        try:
            with open(output_filename, 'r') as f_out:
                print("\nQE Output:")
                print(f_out.read())
        except Exception as e:
            print(f"Could not read output file: {e}")

    except Exception as e:
        print(f"Unexpected error: {e}")

config = {
    'command': '/content/bin/pw.x',
    'pseudo_dir': '/content/ONCVPSP/abinit/',
    'outdir': '/content/tmp',
    'control': {
        'calculation': 'scf',
        'restart_mode': 'from_scratch',
        'pseudo_dir': '/content/ONCVPSP/abinit/',
        'outdir': '/content/tmp',
        'prefix': 'Bi',
        'disk_io': 'medium',
        'wf_collect': True,
        'tprnfor': True,
        'tstress': True,
    },
    'system': {
        'ibrav': 0,
        'occupations': 'smearing',
        'smearing': 'gaussian',
        'degauss': 0.01,
        'noncolin': True,
        'lspinorb': True
    },
    'electrons': {
        'conv_thr': 1.0e-8,
        'mixing_beta': 0.3,
        'electron_maxstep': 300,
    }
}

# ASE structure
# bi = bulk('Bi', 'rhombohedral', a=4.75, c=12.36, orthorhombic=False)
mof = read("/content/mofs/CIYLAA_full.cif")
# Run QE
run_qe(mof, config)
